________________________________________________________________________________

Some of the Problems with Judi's Library:
________________________________________________________________________________

1. Duplicate additions are not reported and are therefore lost
	
	Procedure addToTree returns no errors and does nothing to handle data that
	would otherwise exist in the same location in the tree. This means every
	instance of duplicate entries will result in memory that is lost unless
	tracked elsewhere as well (for instance, in my test program the data was
	not lost because it was tracked in a separate tree structure that did not
	encounter any duplicates). 
	
2. get(Right/Left)Subtree loses track of memory when handling errors

	This one can be described best by the example code I put together.
	
	TL:DR, if you call getLeftSubtree or getRightSubtree on a NULL tree, the
	procedure will allocate memory, encounter an error and return without that
	memory being freed.
	
3. I don't even know how preface this one

	This one I still can't fathom. Basically, rerunning the procedure in the
	example code, which created and destroyed the test tree and data altogether,
	did not display the same behaviour. It faulted upon making insertions to a
	new tree, an empty tree. This tree did not require comparisons in order for
	an entry to be made because the first entry would simply be placed at the
	root. Though, I determined that, in the first call to addToTree, a call to
	the comparison function was erroneously made with one parameter being NULL.
	This caused a fault when it was dereferenced in the comparison function.
	
	On the first run, which ran with no errors, the first call to addToTree did
	NOT make a call to the comparison function, the data was just placed at the
	root. Why? There might be some volatile information hidden in the library,
	I can't be certain though without seeing the decisions made in the source
	code.
	
4. This one is more of a personal gripe with the necessity of a destructor
	
	This is the way I've personally implemented it in my abstract classes so 
	I might be the only one who is annoyed by this.

	The lab requires us to make two separate trees that hold the same data.
	So specifying the same destructor for both trees would cause multiple calls
	to free the same pieces of data. Instead, I have to specify an empty 
	function for one of the trees. I know that Judi's code provides explicit 
	type checking at compile time so I'll give her that, but having the ability
	to specify NULL for the destructor parameter would be a lot simpler for user
	interaction and takes one extra line of code essentially.
	
________________________________________________________________________________